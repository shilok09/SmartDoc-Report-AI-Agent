from langchain_google_community.drive import GoogleDriveLoader
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.prompts import PromptTemplate
from langchain.agents import create_react_agent, AgentExecutor
from langchain import hub
from dotenv import load_dotenv
import os
from datetime import datetime
from typing import Dict, List
from report_agent.backend.google_docs import generate_meeting_report_tool
import logging

# Set up logging
logger = logging.getLogger(__name__)

# Configuration
FOLDER_ID = "<YOUR_GOOGLE_DRIVE_FOLDER_ID>"  # TODO: Insert your Google Drive folder ID here
CLIENT_SECRET_PATH = "<PATH_TO_CLIENT_SECRET_JSON>"  # TODO: Insert path to your client_secret.json

# Load environment variables
load_dotenv()
os.environ["LANGCHAIN_TRACING_V2"] = "true"
token = os.getenv("GITHUB_TOKEN")  # TODO: Set your GitHub token in environment variables
os.environ["OPENAI_API_KEY"] = os.getenv("GITHUB_TOKEN", "<YOUR_OPENAI_API_KEY>")  # TODO: Insert your OpenAI API key
os.environ["OPENAI_API_BASE"] = "<YOUR_OPENAI_API_BASE_URL>"  # TODO: Insert your OpenAI API base URL

# Initialize LLM
llm = ChatOpenAI(
    model="openai/gpt-4.1",
    temperature=0.7
)

# Load Google Drive documents
def load_company_context():
    """Load company documents from Google Drive"""
    try:
        loader = GoogleDriveLoader(
            folder_id=FOLDER_ID, 
            credentials_path=CLIENT_SECRET_PATH,
            token_path="token.json",
            scopes=["https://www.googleapis.com/auth/drive.readonly"]
        )
        docs = loader.load()
        return "\n\n".join([doc.page_content for doc in docs])
    except Exception as e:
        logger.error(f"Error loading company context: {e}")
        return "Company context not available"

# Load context once
COMPANY_CONTEXT = load_company_context()

# Define Tools
@tool
def get_current_datetime() -> str:
    """Get the current date and time information."""
    now = datetime.now()
    return (
        f"Today is {now.strftime('%A')}, "
        f"{now.day} {now.strftime('%B')} {now.year}. "
        f"The current time is {now.strftime('%I:%M %p')}."
    )

@tool
def get_company_context() -> str:
    """Get company context and information from loaded documents."""
    return COMPANY_CONTEXT

@tool
def generate_formal_letter(input_data: str) -> str:
    """Generate a formal company letter using the template format.
    
    Args:
        input_data: JSON string containing letter details with keys:
            - subject: Subject line of the letter (required)
            - main_content: Main body content of the letter (required - should be generated by LLM)
            - recipient_name: Name of the person receiving the letter (optional - should come from company context)
            - address: Full address of the recipient (optional - should come from company context)
            - role: Role/position of the recipient (optional - should be generated by LLM)
    
    Example input: '{"subject": "Job Offer", "main_content": "We are pleased...", "recipient_name": "John Doe", "address": "123 Main St", "role": "Manager"}'
    """
    import json
    
    try:
        # Parse the input JSON
        data = json.loads(input_data)
        
        subject = data.get("subject", "")
        main_content = data.get("main_content", "")
        recipient_name = data.get("recipient_name", "")
        address = data.get("address", "")
        role = data.get("role", "")
        
    except json.JSONDecodeError:
        return "Invalid input format. Please provide a valid JSON string with letter details."
    
    #IF REQUIRED INFORMATION IS MISSING
    if not recipient_name or not address:
        return "Missing recipient information. Please use get_company_context tool first to extract recipient name and address from company documents."
    if not subject:
        return "Cannot generate letter. Subject is required."
    if not main_content:
        return "Cannot generate letter. Main content is required and should be generated based on the letter purpose."
    
    current_date = datetime.now().strftime("%B %d, %Y")
    
    letter_template = f"""[CoreTech ltd.]

    [Date: {current_date}]
    
    {recipient_name}
    {role}
    {address}
    
    Subject: {subject}
    
    Dear {recipient_name},
    
    {main_content}
    
    If you have any questions, feel free to contact us.
    
    Sincerely,
    Alex Morgan
    Chief Executive Officer
    CoreTech Ltd"""

    return letter_template

@tool
def create_google_doc_from_letter(letter_text: str) -> str:
    """Create a Google Doc from the generated letter text and return the URL.
    
    Args:
        letter_text: The complete letter text to convert to Google Doc
    """
    try:
        # Extract fields from letter text using LLM
        extraction_prompt = PromptTemplate(
            input_variables=["letter_text"],
            template="""
            You are a helper that extracts field values from a formal company letter.
            Given this letter, extract and return JSON containing:
            - month: month from date
            - date: day and year from date  
            - name: recipient's name
            - role: recipient's role/position (if mentioned)
            - address: recipient's address
            - subject: subject line
            - text: main body content

            Letter:
            {letter_text}

            Return only valid JSON with these exact keys.
            """
        )
        
        chain = extraction_prompt | llm | JsonOutputParser()
        extracted_data = chain.invoke({"letter_text": letter_text})
        
        # Generate Google Doc
        url = generate_meeting_report_tool(extracted_data)
        return f"Google Doc created successfully! URL: {url}"
    except Exception as e:
        logger.error(f"Error creating Google Doc: {e}")
        return f"Error creating Google Doc: {str(e)}"

# Create tools list
tools = [
    get_current_datetime,
    get_company_context,
    generate_formal_letter,
    create_google_doc_from_letter
]

# Get ReAct prompt from hub
try:
    react_prompt = hub.pull("hwchase17/react")
except Exception as e:
    logger.error(f"Error loading ReAct prompt: {e}")
    # Fallback prompt if hub is unavailable
    from langchain_core.prompts import PromptTemplate
    react_prompt = PromptTemplate(
        input_variables=["tools", "tool_names", "input", "agent_scratchpad"],
        template="""Answer the following questions as best you can. You have access to the following tools:

        {tools}

        Use the following format:

        Question: the input question you must answer
        Thought: you should always think about what to do
        Action: the action to take, should be one of [{tool_names}]
        Action Input: the input to the action
        Observation: the result of the action
        ... (this Thought/Action/Action Input/Observation can repeat N times)
        Thought: I now know the final answer
        Final Answer: the final answer to the original input question

        Begin!

        Question: {input}
        Thought:{agent_scratchpad}"""
    )

# Enhanced system message for letter generation context
SYSTEM_MESSAGE = """
You are a professional AI assistant for generating formal company letters for CoreTech Ltd.

Your workflow should be:
1. First, use get_company_context() to access company documents and extract recipient information (name, address)
2. Get current date/time if needed using get_current_datetime()
3. Based on user request, generate appropriate main_content and role for the letter
4. Use generate_formal_letter() with:
   - subject: provided by user or generated based on purpose
   - main_content: YOU should generate this based on letter purpose
   - recipient_name: extracted from company context
   - address: extracted from company context  
   - role: YOU should generate this if relevant
5. Letter main_content should be of 90-100 words only. 

When helping users:
- Always start by checking company context for recipient details
- Generate professional main content based on the letter purpose
- Use proper formal letter structure
- Offer to create Google Doc after letter is generated

Letter Format Guidelines:
- Use [CoreTech Ltd.] as header
- Include current date
- Proper recipient details (name, role, address)
- Clear subject line
- Professional salutation and closing
- Signed by   Alex Morgan, CEO

The recipient_name and address should come from company context, while main_content and role should be generated by you based on the letter purpose.
"""

class LetterGenerationAgent:
    def __init__(self):
        try:
            # Create ReAct agent
            self.agent = create_react_agent(
                llm=llm,
                tools=tools,
                prompt=react_prompt
            )
            
            # Create agent executor
            self.agent_executor = AgentExecutor(
                agent=self.agent,
                tools=tools,
                verbose=True,
                handle_parsing_errors=True,
                max_iterations=10
            )
            
            self.chat_history = []
            logger.info("LetterGenerationAgent initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing LetterGenerationAgent: {e}")
            raise e
    
    def run(self, user_input: str) -> str:
        """Run the agent with user input and system context"""
        
        # Add system context to the input
        enhanced_input = f"""
        System Context: {SYSTEM_MESSAGE}
        
        Chat History: {self.format_chat_history()}
        
        User Input: {user_input}
        
        Please help the user with their letter generation request. Use the available tools as needed.
        """
        
        try:
            response = self.agent_executor.invoke({"input": enhanced_input})
            result = response["output"]
            
            # Update chat history
            self.chat_history.append(f"User: {user_input}")
            self.chat_history.append(f"Assistant: {result}")
            
            return result
        except Exception as e:
            logger.error(f"Error in agent execution: {e}")
            return f"I apologize, but I encountered an error: {str(e)}. Please try again."
    
    def format_chat_history(self) -> str:
        """Format chat history for context"""
        if not self.chat_history:
            return "No previous conversation."
        return "\n".join(self.chat_history[-6:])  # Keep last 6 messages for context